"use strict";(self.webpackChunkapp=self.webpackChunkapp||[]).push([["83"],{334:function(n,e,t){t.r(e),t.d(e,{default:()=>l});var r=t(4132),i=t(9546),s=t(8428);function c(n){let e={h1:"h1",h2:"h2",p:"p",...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{children:"flushSync"}),"\n",(0,r.jsx)(e.p,{children:"flushSync 允许你强制 React 在提供的回调函数内同步刷新任何更新，这将确保 DOM 立即更新。"}),"\n",(0,r.jsx)(e.p,{children:":::tip\n使用 flushSync 是不常见的行为，可能会严重影响性能，因此请谨慎使用。"}),"\n",(0,r.jsx)(e.p,{children:"不需要使用 flushSync，请将其作为最后的手段使用。\n:::"}),"\n",(0,r.jsx)(e.h2,{children:"用法"}),"\n",(0,r.jsx)(e.p,{children:"flushSync 返回 undefined。"})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}let l=function(){let[n,e]=(0,i.useState)(!1);return(0,i.useEffect)(()=>{function n(){(0,s.flushSync)(()=>{e(!0)})}function t(){e(!1)}return window.addEventListener("beforeprint",n),window.addEventListener("afterprint",t),()=>{window.removeEventListener("beforeprint",n),window.removeEventListener("afterprint",t)}},[]),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(h,{}),(0,r.jsx)("h1",{children:"官方例子"}),(0,r.jsxs)("h1",{children:["是否打印：",n?"是":"否"]}),(0,r.jsx)("button",{onClick:()=>window.print(),children:"打印"})]})}}}]);